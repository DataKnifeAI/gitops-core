apiVersion: v1
kind: ConfigMap
metadata:
  name: cert-sync-script
  namespace: cert-manager
  labels:
    app: cert-manager
    managed-by: gitops
    purpose: cert-sync
data:
  sync-certs.sh: |
    #!/bin/bash
    #
    # Sync TLS certificates from rancher-manager cluster to downstream clusters
    #
    # This script copies TLS secrets generated by cert-manager on rancher-manager
    # to downstream clusters (nprd-apps, poc-apps, prd-apps), reducing Let's Encrypt
    # certificate requests from 8 (4 clusters √ó 2 certs) to just 2 (wildcard-net, wildcard-ai).
    #
    # It also copies wildcard-dataknife-net-tls to kube-system namespace on all clusters
    # (including rancher-manager) for the default ingress controller, avoiding duplicate
    # certificate requests for the same DNS names.
    #
    set -euo pipefail

    SOURCE_CLUSTER="rancher-manager"
    DOWNSTREAM_CLUSTERS=("nprd-apps" "poc-apps" "prd-apps")

    # Secrets to copy: namespace/secret-name
    # Note: We only request wildcard-dataknife-net-tls once in cert-manager namespace,
    # then copy it to kube-system for default ingress (avoids duplicate Let's Encrypt requests)
    SECRETS=(
        "cert-manager/wildcard-dataknife-net-tls"
    )
    
    # Special: Copy wildcard-dataknife-net-tls to kube-system for default ingress
    # This uses the same secret from cert-manager namespace, just in a different namespace
    DEFAULT_INGRESS_SECRET="cert-manager/wildcard-dataknife-net-tls"
    DEFAULT_INGRESS_TARGET="kube-system/wildcard-dataknife-net-tls"

    # Ensure kubectl is available and kubeconfig is set
    if ! command -v kubectl &> /dev/null; then
        echo "‚ùå Error: kubectl not found"
        exit 1
    fi

    if [[ -z "${KUBECONFIG:-}" ]]; then
        echo "‚ùå Error: KUBECONFIG environment variable not set"
        exit 1
    fi

    # Function to copy a secret from source to target cluster
    copy_secret() {
        local source_ctx="$1"
        local target_ctx="$2"
        local namespace="${3%%/*}"
        local secret_name="${3##*/}"

        echo "  Copying ${namespace}/${secret_name} from ${source_ctx} to ${target_ctx}..."

        # Check if secret exists on source cluster
        if ! kubectl --context="${source_ctx}" get secret -n "${namespace}" "${secret_name}" >/dev/null 2>&1; then
            echo "    ‚ö†Ô∏è  Secret ${namespace}/${secret_name} not found on ${source_ctx}, skipping..."
            return 1
        fi

        # Get secret data from source cluster
        local secret_data
        secret_data=$(kubectl --context="${source_ctx}" get secret -n "${namespace}" "${secret_name}" -o json)

        # Extract data and create new secret manifest (preserving type, labels, annotations)
        local new_secret
        new_secret=$(echo "${secret_data}" | jq -c '{
            apiVersion: "v1",
            kind: "Secret",
            metadata: {
                name: .metadata.name,
                namespace: .metadata.namespace,
                labels: (.metadata.labels // {}),
                annotations: (.metadata.annotations // {})
            },
            type: .type,
            data: .data
        }')

        # Apply to target cluster
        echo "${new_secret}" | kubectl --context="${target_ctx}" apply -f -

        echo "    ‚úÖ Secret ${namespace}/${secret_name} synced successfully"
    }

    # Function to copy secret to a different namespace (for default ingress)
    copy_secret_to_namespace() {
        local source_ctx="$1"
        local target_ctx="$2"
        local source_ns="${3%%/*}"
        local secret_name="${3##*/}"
        local target_ns="${4%%/*}"
        
        echo "  Copying ${source_ns}/${secret_name} to ${target_ns}/${secret_name} on ${target_ctx}..."
        
        # Check if secret exists on source cluster
        if ! kubectl --context="${source_ctx}" get secret -n "${source_ns}" "${secret_name}" >/dev/null 2>&1; then
            echo "    ‚ö†Ô∏è  Secret ${source_ns}/${secret_name} not found on ${source_ctx}, skipping..."
            return 1
        fi
        
        # Get secret data from source cluster
        local secret_data
        secret_data=$(kubectl --context="${source_ctx}" get secret -n "${source_ns}" "${secret_name}" -o json)
        
        # Create new secret manifest with target namespace
        local new_secret
        new_secret=$(echo "${secret_data}" | jq -c --arg ns "${target_ns}" '{
            apiVersion: "v1",
            kind: "Secret",
            metadata: {
                name: .metadata.name,
                namespace: $ns,
                labels: (.metadata.labels // {}),
                annotations: (.metadata.annotations // {})
            },
            type: .type,
            data: .data
        }')
        
        # Apply to target cluster
        echo "${new_secret}" | kubectl --context="${target_ctx}" apply -f -
        
        echo "    ‚úÖ Secret ${target_ns}/${secret_name} synced successfully"
    }

    # Function to sync secrets to a target cluster
    sync_to_cluster() {
        local target_cluster="$1"
        
        echo ""
        echo "üîÑ Syncing certificates to ${target_cluster}..."
        
        # Copy main secrets
        for secret in "${SECRETS[@]}"; do
            copy_secret "${SOURCE_CLUSTER}" "${target_cluster}" "${secret}" || true
        done
        
        # Copy wildcard-dataknife-net-tls to kube-system for default ingress
        # This avoids requesting the same certificate twice from Let's Encrypt
        copy_secret_to_namespace "${SOURCE_CLUSTER}" "${target_cluster}" \
            "${DEFAULT_INGRESS_SECRET}" "${DEFAULT_INGRESS_TARGET}" || true
        
        echo "‚úÖ Finished syncing to ${target_cluster}"
    }

    # Sync to all clusters (including rancher-manager itself for kube-system copy)
    ALL_CLUSTERS=("${SOURCE_CLUSTER}" "${DOWNSTREAM_CLUSTERS[@]}")
    
    echo "üìã Syncing certificates from ${SOURCE_CLUSTER} to all clusters..."
    for cluster in "${ALL_CLUSTERS[@]}"; do
        sync_to_cluster "${cluster}"
    done
    echo ""
    echo "‚úÖ Certificate sync complete!"

#!/bin/bash
#
# Sync TLS certificates from rancher-manager cluster to downstream clusters
#
# This script copies TLS secrets generated by cert-manager on rancher-manager
# to downstream clusters (nprd-apps, poc-apps, prd-apps), reducing Let's Encrypt
# certificate requests from 8 (4 clusters √ó 2 certs) to just 2 (wildcard-net, wildcard-ai).
#
# Secrets to copy:
# - cert-manager/wildcard-dataknife-net-tls
# - kube-system/wildcard-dataknife-net-tls (for nginx default SSL)
#
# Usage:
#   ./sync-certs-from-rancher-manager.sh [target-cluster]
#   If target-cluster is not specified, syncs to all downstream clusters
#
# Prerequisites:
#   - kubectl configured with contexts: rancher-manager, nprd-apps, poc-apps, prd-apps
#   - Secrets must exist on rancher-manager cluster

set -euo pipefail

SOURCE_CLUSTER="rancher-manager"
DOWNSTREAM_CLUSTERS=("nprd-apps" "poc-apps" "prd-apps")

# Secrets to copy: namespace/secret-name
# Note: We only request wildcard-dataknife-net-tls once in cert-manager namespace,
# then copy it to kube-system for default ingress (avoids duplicate Let's Encrypt requests)
SECRETS=(
    "cert-manager/wildcard-dataknife-net-tls"
)

# Special: Copy wildcard-dataknife-net-tls to kube-system for default ingress
DEFAULT_INGRESS_SECRET="cert-manager/wildcard-dataknife-net-tls"
DEFAULT_INGRESS_TARGET_NS="kube-system"

# Function to copy a secret from source to target cluster
copy_secret() {
    local source_ctx="$1"
    local target_ctx="$2"
    local namespace="${3%%/*}"
    local secret_name="${3##*/}"

    echo "  Copying ${namespace}/${secret_name} from ${source_ctx} to ${target_ctx}..."

    # Check if secret exists on source cluster
    if ! kubectl --context="${source_ctx}" get secret -n "${namespace}" "${secret_name}" >/dev/null 2>&1; then
        echo "    ‚ö†Ô∏è  Secret ${namespace}/${secret_name} not found on ${source_ctx}, skipping..."
        return 1
    fi

    # Get secret data from source cluster
    local secret_data
    secret_data=$(kubectl --context="${source_ctx}" get secret -n "${namespace}" "${secret_name}" -o json)

    # Extract secret type
    local secret_type
    secret_type=$(echo "${secret_data}" | jq -r '.type // "Opaque"')

    # Extract data and create new secret manifest
    local new_secret
    new_secret=$(echo "${secret_data}" | jq -c '{
        apiVersion: "v1",
        kind: "Secret",
        metadata: {
            name: .metadata.name,
            namespace: .metadata.namespace,
            labels: (.metadata.labels // {}),
            annotations: (.metadata.annotations // {})
        },
        type: .type,
        data: .data
    }')

    # Apply to target cluster
    echo "${new_secret}" | kubectl --context="${target_ctx}" apply -f -

    echo "    ‚úÖ Secret ${namespace}/${secret_name} synced successfully"
}

# Function to copy secret to a different namespace (for default ingress)
copy_secret_to_namespace() {
    local source_ctx="$1"
    local target_ctx="$2"
    local source_ns="${3%%/*}"
    local secret_name="${3##*/}"
    local target_ns="$4"
    
    echo "  Copying ${source_ns}/${secret_name} to ${target_ns}/${secret_name} on ${target_ctx}..."
    
    # Check if secret exists on source cluster
    if ! kubectl --context="${source_ctx}" get secret -n "${source_ns}" "${secret_name}" >/dev/null 2>&1; then
        echo "    ‚ö†Ô∏è  Secret ${source_ns}/${secret_name} not found on ${source_ctx}, skipping..."
        return 1
    fi
    
    # Get secret data from source cluster
    local secret_data
    secret_data=$(kubectl --context="${source_ctx}" get secret -n "${source_ns}" "${secret_name}" -o json)
    
    # Create new secret manifest with target namespace
    local new_secret
    new_secret=$(echo "${secret_data}" | jq -c --arg ns "${target_ns}" '{
        apiVersion: "v1",
        kind: "Secret",
        metadata: {
            name: .metadata.name,
            namespace: $ns,
            labels: (.metadata.labels // {}),
            annotations: (.metadata.annotations // {})
        },
        type: .type,
        data: .data
    }')
    
    # Apply to target cluster
    echo "${new_secret}" | kubectl --context="${target_ctx}" apply -f -
    
    echo "    ‚úÖ Secret ${target_ns}/${secret_name} synced successfully"
}

# Function to sync secrets to a target cluster
sync_to_cluster() {
    local target_cluster="$1"
    
    echo ""
    echo "üîÑ Syncing certificates to ${target_cluster}..."
    
    # Copy main secrets
    for secret in "${SECRETS[@]}"; do
        copy_secret "${SOURCE_CLUSTER}" "${target_cluster}" "${secret}" || true
    done
    
    # Copy wildcard-dataknife-net-tls to kube-system for default ingress
    # This avoids requesting the same certificate twice from Let's Encrypt
    copy_secret_to_namespace "${SOURCE_CLUSTER}" "${target_cluster}" \
        "${DEFAULT_INGRESS_SECRET}" "${DEFAULT_INGRESS_TARGET_NS}" || true
    
    echo "‚úÖ Finished syncing to ${target_cluster}"
}

# Main logic
TARGET_CLUSTER="${1:-}"

if [[ -n "${TARGET_CLUSTER}" ]]; then
    # Sync to specific cluster
    if [[ ! " ${DOWNSTREAM_CLUSTERS[*]} " =~ " ${TARGET_CLUSTER} " ]]; then
        echo "‚ùå Error: ${TARGET_CLUSTER} is not a downstream cluster."
        echo "   Valid downstream clusters: ${DOWNSTREAM_CLUSTERS[*]}"
        exit 1
    fi
    sync_to_cluster "${TARGET_CLUSTER}"
else
    # Sync to all downstream clusters
    echo "üìã Syncing certificates from ${SOURCE_CLUSTER} to all downstream clusters..."
    for cluster in "${DOWNSTREAM_CLUSTERS[@]}"; do
        sync_to_cluster "${cluster}"
    done
    echo ""
    echo "‚úÖ Certificate sync complete!"
fi
